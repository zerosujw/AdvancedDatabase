## Entity relational diagram

![](屏幕截图%202023-11-21%20083302.png)

Every table has a primary key used to identify each consumer, product, order or order details. They are: `consumer_id`, `product_id`, `order_id` and `order_detail_id`.

The attribute `consumer_id` of `Orders` table is a reference (foreign key) of `consumer_id` of `Consumers` table.
Every order has a consumer. And every consumer should be in `Consumers` table.
The cardinality is one-to-many. One consumer may have multiple orders.

The attribute `order_id` in `OrderDetails` table links to `Orders` table. The attribute `product_id` links to `Products` table. They are also one-to-many. One order can have multiple details which means multiple products. These foreign keys created associations and enables tracking of information between different tables.

## SQL queries

Insert 6 unique consumers:

```sql
INSERT INTO "Consumers"
VALUES
	(1, 'Abby', 'Abby@gmail.com', 'Berlin'),
	(2, 'Bob', 'Bob@hotmail.com', 'Munchen'),
	(3, 'Carl', 'Carl@yahoo.com', 'Achen'),
	(4, 'Darlin', 'Darlin@apple.com', 'Sarrland'),
	(5, 'Ela', 'Ela@mit.com', 'Dusseldurf'),
	(6, 'Finka', 'Finka@openai.com', 'Bremen');
```

It seems that PostgreSQL uses double quote to denote delimited identifies, rather than strings. These identifiers are case sensitive. Single quote are used to indicate strings.
The table names generated by ERD tool are case sensitive.

Insert 5 different products:

```sql
INSERT INTO "Products"
VALUES
	(1, 'Rainbow Six', 30),
	(2, 'Far Cry', 60),
	(3, 'Elden Ring', 60),
	(4, 'Baldurs Gate', 60),
	(5, 'Ratchet and Clank', 70);
```

Insert 2 orders per customer:

```sql
INSERT INTO "Orders"
VALUES
	(1, 1, '2023-11-21'),
	(2, 1, '2023-11-22'),
	(3, 2, '2023-11-23'),
	(4, 2, '2023-11-24'),
	(5, 3, '2023-11-25'),
	(6, 3, '2023-11-26'),
	(7, 4, '2023-11-27'),
	(8, 4, '2023-11-28'),
	(9, 5, '2023-11-29'),
	(10, 5, '2023-11-30'),
	(11, 6, '2023-12-01'),
	(12, 6, '2023-12-02');
```

Insert 2 products per order:

```sql
INSERT INTO "OrderDetails" (order_detail_id, order_id, product_id, quantity)
VALUES
	(1, 1, 1, 3),
	(2, 1, 2, 2),
	(3, 2, 3, 1),
	(4, 2, 4, 4),
	(5, 3, 1, 2),
	(6, 3, 3, 3),
	(7, 4, 2, 5),
	(8, 4, 4, 1),
	(9, 5, 1, 4),
	(10, 5, 3, 2),
	(11, 6, 2, 3),
	(12, 6, 4, 2),
	(13, 7, 1, 1),
	(14, 7, 3, 4),
	(15, 8, 2, 2),
	(16, 8, 4, 3),
	(17, 9, 1, 3),
	(18, 9, 3, 1),
	(19, 10, 2, 4),
	(20, 10, 4, 2),
	(21, 11, 1, 2),
	(22, 11, 3, 3),
	(23, 12, 2, 1),
	(24, 12, 4, 4);
```

List all customers:

```sql
select * from "Consumers";
```

List all products:

```sql
select * from "Products";
```

List all orders along with the corresponding customer’s name, product name and quantity, using `JOIN`:

```postgresql
select order_id, "Consumers".name, "Products".name, quantity
from "Orders"
natural join "OrderDetails"
natural join "Consumers"
join "Products" on "OrderDetails".product_id="Products".product_id;
```

We are using natural join because it's a more efficient way when you don't have conflict attribute names.

## Backup

At first, right-click on the database in pgAdmin and select "Backup.." result in a failed process with `exit code: 3221225781`.

But after seaching the Internet, we found that we need to change the `Binary paths` of pgAdmin to `\PostgreSQL\bin`.

Then the backup process could be done successfully.
